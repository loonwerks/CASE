# LMCPGen

[LMCPGen](https://github.com/afrl-rq/LmcpGen) autogenerates source-code libraries that conform to the serialization specification of LMCP. I downloaded the [latest release](https://github.com/afrl-rq/LmcpGen/releases).

The code documentation and code in generated as follows.

```
$ mkdir OpenUxAS; cd OpenUxAS
$ java -jar LmcpGen.jar -mdmdir "~/case-ta6-experimental-platform-OpenUxAS/mdms" -doc -dir "doc/LMCP"
$ java -jar LmcpGen.jar -mdmdir "~/case-ta6-experimental-platform-OpenUxAS/mdms" -cpp -dir "src/LMCP"
```

The sources creates directories for each of the namespaces and in those it places the generated code for each message type according to namespace. The `avtas/lmcp` directory has the `lmcp` base types for the messages. It also has the `Factory` method used by `OpenUxAS` to create the `lmcp` objects for communication.

# LMCP Object

*LMCP object* in this context is defined by the  `void Factory::putObject(const Object* o, ByteBuffer & buffer)` method created by `LMCPGen`. That method is found in `avtas/lmcp/Factory.cpp` and the code is below for convenience. Intuitively, an LMCP Object is a header followed by the *packed object*. Byte-order is **big-endian** for all multi-byte types.

**Non-null Object**

  * `bool`: `true` (this entry is not `null`)
  * `int64_t`: Series ID
  * `uint32_t`: Type ID
  * `uint16_t`: Series version
  *  Packed object (see below)
 
**NULL Object**

  * `bool`: `false` (this entry is `null`)

The ID, type, and version are defined in the source for the individual messages (e.g., `afrlcmasiOperatingRegion.cp`). There are corresponding string versions for the ID and type in that same file. 

**Beware**: the actual representation of a boolean depends on that used in the LMCP source language (C++) and that language doesn't say what bit patterns are used for true and false. See [https://stackoverflow.com/questions/19351483/how-is-a-bool-represented-in-memory](https://stackoverflow.com/questions/19351483/how-is-a-bool-represented-in-memory)

```c++
void Factory::putObject(const Object* o, ByteBuffer & buffer)
{
    if (!o)
    {
        buffer.putBool(false);
    }
    else
    {
        buffer.putBool(true);
        buffer.putLong(o->getSeriesNameAsLong());
        buffer.putUInt(o->getLmcpType());
        buffer.putUShort(o->getSeriesVersion());
        o->pack(buffer);
    }
}
```

## Packed Object

The size of the packed object depends on the type and is made clear in the `pack` method for the message type. All arrays are preceded by the size of the array as a `unit16` number. If the object has fields that are also objects, then those field are packed using their LMCP Object definition above by calling the `void Factory::putObject(const Object* o, ByteBuffer & buffer)` method. Arrays over primitives are as expected. Arrays over objects become arrays over LMCP objects.

### Packed OperatingRegion

  * `int64_t`: ID (operating region ID)
  * `uint16_t`: `KeepInAreas` array length (array size)
  * `length * sizeof(uint64_t)`: array of `KeepInArea` IDs
  * `uint16_t`: `KeepOutAreas` array length
  * `length * sizeof(uint64_t)`: array of `KeepOutArea` IDs

# LMCP Messages

An *LMPC Message* is an LMCP Object with a *header* and *checksum* footer. See the `Object * Factory::getObject(ByteBuffer & buffer)` in `avtas/lmcp/Factory.cpp` generated by `LMCPGen` below for details.  The header, consisting of a control string and message size, is 8 bytes and the checksum is 4 bytes.

  * `int32_t`: LMCP control string (`0x4c4d4350`)
  * `uint32_t`: Message size
  * LMCP Object
  * `uint32_t`: Checksum

```cpp
Object * Factory::getObject(ByteBuffer & buffer)
{
    if (buffer.capacity() < HEADER_SIZE + CHECKSUM_SIZE)
    {
        std::cerr << "Error (Factory::getObject): buffer at least as big as"
                << " header + checksum (" << HEADER_SIZE + CHECKSUM_SIZE << ").\n";
        return nullptr;
    }

    int32_t ctrl_str = buffer.getInt();
    if ( ctrl_str != LMCP_CONTROL_STR)
    {
        std::cerr << "Error (Factory::getObject): Not a proper LMCP message.";
        std::cerr << "   Expected: " << LMCP_CONTROL_STR << "   Received: " << ctrl_str << std::endl;
        return nullptr;
    }

    uint32_t msgsize = buffer.getUInt();
    if ( buffer.capacity() < msgsize )
    {
        std::cerr << "Error (Factory::getObject): Buffer size too small for packed object.";
        std::cerr << "   MsgSize: " << msgsize << "    Capacity: " << buffer.capacity() << std::endl;
        return nullptr;
    }

    // validate the buffer's checksum
    if (!validate(buffer.array(), buffer.capacity()))
    {
        std::cerr << "Error (SeriesFactory::getObject): checksum invalid.\n";
        return nullptr;
    }

    if(!buffer.getBool())
    {
        std::cerr << "Message indicated it was packed as NULL\n";
        return nullptr;
    }

    int64_t series_id = buffer.getLong();
    uint32_t msgtype = buffer.getUInt();
    uint16_t version = buffer.getUShort();
    Object* o = Factory::createObject(series_id, msgtype, version);

    if (o != nullptr)
    {
        o->unpack(buffer);
    }
    else
    {
        std::cerr << "Buffer does not contain a recognized object type. \n";
    }

    return o;
}
```

# Other Bridges

There are two types of messages that only seem to differ slightly in header format. The notes in [UxAS_main.cpp](https://github.com/loonwerks/case-ta6-experimental-platform-OpenUxAS/blob/develop-case-ta6/src/UxAS_Main.cpp) indicate that the `AddressAttributedMessage` is the correct format. These messages are used to go on and off different transport layers (e.g., TCP/IP, ZeroMQ, etc.) and their payload is the LMCP message.

## Address Attributed Message

The message is an address followed by a set of attributes and then the payload. The attributes are defined in [MessageAttributes.h](https://github.com/loonwerks/case-ta6-experimental-platform-OpenUxAS/blob/develop-case-ta6/src/Communications/MessageAttributes.h) and are delimited by the `|` character. A `$` character delimits the address from the attributes and the attributes from the payload. [AddressAttributedMessage.h](https://github.com/loonwerks/case-ta6-experimental-platform-OpenUxAS/blob/develop-case-ta6/src/Communications/AddressedAttributedMessage.h) gives actual format (see `bool setAddressAttributesAndPayload`).


  * `string`: Notational address (e.g., `uxas.project.isolate.IntruderAlert`, `uxas.roadmonitor`, etc.)
  * `$`: delimiter
  * `string` : Content type (e.g., `lmcp`, `json`, `xml`, etc.)
  * `|`: delimiter
  * `string`: Descriptor (e.g., `afrl.cmasi.OperatingRegion` if content type is `lmcp`, etc.)
  * `|`: delimiter
  * `string`: Source group (e.g., `uxas.roadmonitor`, etc.)
  * `|`: delimiter
  * `string`: Source entity ID
  * `|`: delimiter
  * `string`: Source service ID
  * `$`: delimiter
  * LMCP Message: (see above)

The format is address `$` payload. (See `AddressedMessage.h`). Ah. The real stuff is in `AddressAttributedMessage`. It has both the address and the attributes.

## Addressed Message

Same as above but without the attributes.
