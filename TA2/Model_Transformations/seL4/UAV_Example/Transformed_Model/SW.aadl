package SW
public
	with Data_Model;

	with Base_Types;

	with CASE_Properties;

	with CASE_Model_Transformations;

	data Coordinate
	end Coordinate;

	data implementation Coordinate.Impl
		-- This is the structure to hold the lat/long/alt values of a coordinate
		subcomponents
			latitude: data Base_Types::Integer;
			longitude: data Base_Types::Integer;
			altitude: data Base_Types::Integer;
	end Coordinate.Impl;

	data Map
		-- The Map is a structure that contains a list of coordinates that encircle a
		-- region.  
		-- In this implementation, we fix the size of the map to 4 waypoints
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Coordinate.Impl));
			Data_Model::Dimension => (4);
	end Map;

	data MapArray
		-- The MapArray is a structure that hold multiple Maps
		-- In this implementation, we fix the size of the map array to 5 maps
		-- Future versions will use an array
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Map));
			Data_Model::Dimension => (5);
	end MapArray;

	data FlightPattern
		-- The Flight Pattern is an enumeration that defines how the UAV will fly through the
		-- sensing region to conduct surveillance.
		properties
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("ZigZag", "StraightLine", "Perimeter");
	end FlightPattern;

	data implementation FlightPattern.Impl
	end FlightPattern.Impl;

	data Command
	end Command;

	data implementation Command.Impl
		-- The Command structure contains data that the Ground Station passes to the UAV.
		-- It contains a message header, Map and Flight Pattern.
		subcomponents
			map: data Map;
			pattern: data FlightPattern;
	end Command.Impl;

	data RF_Msg extends CASE_Model_Transformations::CASE_RF_Msg
	end RF_Msg;

	data implementation RF_Msg.Impl extends CASE_Model_Transformations::CASE_RF_Msg.Impl
		subcomponents
			payload: refined to data Command.Impl;
	end RF_Msg.Impl;

	data Mission
		-- The Mission is a list of waypoints that is generated by the Flight Planner based on a
		-- Map and Flight Pattern.
		-- For this implementation, we fix the size of the Mission to 10 waypoints.
		-- Future versions will use an array
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Coordinate.Impl));
			Data_Model::Dimension => (10);
	end Mission;

	data MissionWindow
		-- The Mission Window is a list of waypoints that the Waypoint Manager assembles from the Mission.
		-- For this implementation, we fix the size of the Mission Window to 4 waypoints.
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Coordinate.Impl));
			Data_Model::Dimension => (4);
	end MissionWindow;

--	thread WifiDriver
--		-- The WifiDriver is the software that enables other SW components to communicate to other systems over WiFi
--		features
--			gimbal_command: in event data port;
--			send_data: out event data port CASE_Model_Transformations::CASE_WIFI_Msg.Impl;
--			recv_data: in event data port CASE_Model_Transformations::CASE_WIFI_Msg.Impl;
--	end WifiDriver;
--
--	thread implementation WifiDriver.Impl
--	end WifiDriver.Impl;
	

	thread RadioDriver
		-- The RadioDriver is the software that enables other SW components to communicate to other systems over RF
		features
			recv_data: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			send_data: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			mission_command: out event data port RF_Msg.Impl;
			status: in event data port Coordinate.Impl;
		properties
			CASE_Properties::Component_Type => COMM_DRIVER;
		annex agree {**
			guarantee Req001_RadioDriver "Only valid command messages shall be forwarded to message destination components" : VALID_MESSAGE(mission_command);
		**};
	end RadioDriver;


	thread implementation RadioDriver.Impl
	end RadioDriver.Impl;
	
	process RadioDriver_seL4
		features
			recv_data: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			send_data: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			mission_command: out event data port RF_Msg.Impl;
			status: in event data port Coordinate.Impl;
		properties
			CASE_Properties::Component_Type => COMM_DRIVER;
	end RadioDriver_seL4;
	
	
	process implementation RadioDriver_seL4.Impl
		subcomponents
			RadioDriver: thread RadioDriver.Impl;
		connections
			c1: port RadioDriver.mission_command -> mission_command;
			c2: port RadioDriver.send_data -> send_data;
			c3: port recv_data -> RadioDriver.recv_data;
			c4: port status -> RadioDriver.status;
		annex agree {**
			lift contract;
		**};
	end RadioDriver_seL4.Impl;
	

	thread FlightPlanner
		-- The FlightPlanner is an abstraction for UxAS.
		-- It accepts a command message containing a map and flight pattern, and generates a mission.
		-- The FlightPlanner also has access to a No-Fly zone database, which it uses to generate the mission 
		-- to avoid specified no-fly zones
		features
			flight_plan: out data port Mission;
			nofly_zones: in data port MapArray;
			recv_map: in event data port RF_Msg.Impl;
			position_status: in event data port Coordinate.Impl;
		annex agree {**
			assume Req001_FlightPlanner "The Flight Planner shall receive a valid message from the Ground Station" : VALID_MESSAGE(recv_map);
			guarantee Req002_FlightPlanner "The Flight Planner shall generate a valid mission" : good_mission(flight_plan);
		**};
	end FlightPlanner;

	thread implementation FlightPlanner.Impl
	end FlightPlanner.Impl;
	
	process FlightPlanner_seL4
		-- The FlightPlanner is an abstraction for UxAS.
		-- It accepts a command message containing a map and flight pattern, and generates a mission.
		-- The FlightPlanner also has access to a No-Fly zone database, which it uses to generate the mission 
		-- to avoid specified no-fly zones
		features
			nofly_zones: in data port MapArray;
			recv_map: in event data port RF_Msg.Impl;
			position_status: in event data port Coordinate.Impl;
			flight_plan: out data port Mission;
		annex agree {**
			lift contract;
		**};
	end FlightPlanner_seL4;

	process implementation FlightPlanner_seL4.Impl
		subcomponents
			FlightPlanner: thread FlightPlanner.Impl;
		connections
			c1: port nofly_zones -> FlightPlanner.nofly_zones;
			c2: port recv_map -> FlightPlanner.recv_map;
			c3: port position_status -> FlightPlanner.position_status;
			c4: port FlightPlanner.flight_plan -> flight_plan;
	end FlightPlanner_seL4.Impl;
	

	thread NoFlyZoneDatabase
		-- The NoFlyZoneDatabase is a collection of polygons that represent areas on a map which the UAV should avoid.
		-- The database is populated at build-time and stored in memory.
		-- When provided a map of a region, it will return all no-fly areas within that region.
		features
			zones: out data port MapArray;
	end NoFlyZoneDatabase;

	thread implementation NoFlyZoneDatabase.Impl
	end NoFlyZoneDatabase.Impl;
	
	process NoFlyZoneDatabase_seL4
		-- The NoFlyZoneDatabase is a collection of polygons that represent areas on a map which the UAV should avoid.
		-- The database is populated at build-time and stored in memory.
		-- When provided a map of a region, it will return all no-fly areas within that region.
		features
			zones: out data port MapArray;
	end NoFlyZoneDatabase_seL4;

	process implementation NoFlyZoneDatabase_seL4.Impl
		subcomponents
			NoFlyZoneDatabase: thread NoFlyZoneDatabase.Impl;
		connections
			c1: port NoFlyZoneDatabase.zones -> zones;
	end NoFlyZoneDatabase_seL4.Impl;
	

	thread WaypointManager
		-- The WaypointManager divides a mission into a small window of waypoints suitable for the FlightController.
		-- Because the FlightController can only process a small number of waypoints at a time, the WaypointManager
		-- creates these mission windows in response to the current position of the UAV, provided by the FlightController GPS.
		features
			flight_plan: in data port Mission;
			mission_window: out event data port MissionWindow;
			position_status: in event data port Coordinate.Impl;
		annex agree {**
			assume Req001_WaypointManager "The Waypoint Manager shall receive a well-formed mission" : good_mission(flight_plan);
			guarantee Req002_WaypointManager "The Waypoint Manager shall output a well-formed mission window" : good_mission_window(mission_window);
		**};
	end WaypointManager;

	thread implementation WaypointManager.Impl
	end WaypointManager.Impl;
	
	process WaypointManager_seL4
		-- The WaypointManager divides a mission into a small window of waypoints suitable for the FlightController.
		-- Because the FlightController can only process a small number of waypoints at a time, the WaypointManager
		-- creates these mission windows in response to the current position of the UAV, provided by the FlightController GPS.
		features
			flight_plan: in data port Mission;
			position_status: in event data port Coordinate.Impl;
			mission_window: out event data port MissionWindow;
		annex agree {**
			lift contract;
		**};
	end WaypointManager_seL4;

	process implementation WaypointManager_seL4.Impl
		subcomponents
			WaypointManager: thread WaypointManager.Impl;
		connections
			c1: port flight_plan -> WaypointManager.flight_plan;
			c2: port position_status -> WaypointManager.position_status;
			c3: port WaypointManager.mission_window -> mission_window;
	end WaypointManager_seL4.Impl;
	
	
	thread group UxAS
		features
--			flight_plan: out data port Mission;
			recv_map: in event data port RF_Msg.Impl;
			position_status: in event data port Coordinate.Impl;
			mission_window: out event data port MissionWindow;
	end UxAS;
	
	thread group implementation UxAS.Impl
		subcomponents
			FPLN: thread FlightPlanner.Impl;
			NFDB: thread NoFlyZoneDatabase.Impl;
			WPM: thread WaypointManager.Impl;
		connections
			c1: port recv_map -> FPLN.recv_map;
			c2: port FPLN.flight_plan -> WPM.flight_plan;
			c3: port NFDB.zones -> FPLN.nofly_zones;
			c4: port WPM.mission_window -> mission_window;
			c5: port position_status -> FPLN.position_status;
			c6: port position_status -> WPM.position_status;
--			c7: port FPLN.flight_plan -> flight_plan;
	end UxAS.Impl;
	
		thread group UxAS_VM
		features
			flight_plan: out data port Mission;
			recv_map: in event data port RF_Msg.Impl;
			position_status: in event data port Coordinate.Impl;
--			mission_window: out event data port MissionWindow;
	end UxAS_VM;
	
	thread group implementation UxAS_VM.Impl
		subcomponents
			FPLN: thread FlightPlanner.Impl;
			NFDB: thread NoFlyZoneDatabase.Impl;
		connections
			c1: port recv_map -> FPLN.recv_map;
			c2: port FPLN.flight_plan -> flight_plan;
			c3: port NFDB.zones -> FPLN.nofly_zones;
--			c4: port WPM.mission_window -> mission_window;
			c5: port position_status -> FPLN.position_status;
--			c6: port position_status -> WPM.position_status;
--			c7: port FPLN.flight_plan -> flight_plan;
	end UxAS_VM.Impl;
	
	system UxAS_seL4
		features
			recv_map: in event data port RF_Msg.Impl;
			position_status: in event data port Coordinate.Impl;
--			flight_plan: out data port Mission;
			mission_window: out event data port MissionWindow;
	end UxAS_seL4;
	
	system implementation UxAS_seL4.Impl
		subcomponents
			FPLN: process FlightPlanner_seL4.Impl;
			NFDB: process NoFlyZoneDatabase_seL4.Impl;
			WPM: process WaypointManager_seL4.Impl;
		connections
			c1: port recv_map -> FPLN.recv_map;
			c2: port FPLN.flight_plan -> WPM.flight_plan;
			c3: port NFDB.zones -> FPLN.nofly_zones;
			c4: port WPM.mission_window -> mission_window;
			c5: port position_status -> FPLN.position_status;
			c6: port position_status -> WPM.position_status;
--			c7: port FPLN.flight_plan -> flight_plan;
	end UxAS_seL4.Impl;
	
	process VirtualMachine1
		features
			recv_map: in event data port RF_Msg.Impl;
			position_status: in event data port Coordinate.Impl;
			flight_plan: out data port Mission;
	end VirtualMachine1;
	
	process implementation VirtualMachine1.Impl
		subcomponents
			UxAS: thread group UxAS_VM.Impl;
		connections
			c1: port recv_map -> UxAS.recv_map;
			c2: port position_status -> UxAS.position_status;
			c3: port UxAS.flight_plan -> flight_plan;
	end VirtualMachine1.Impl;
	
	process VirtualMachine2
		features
			recv_map: in event data port RF_Msg.Impl;
			position_status: in event data port Coordinate.Impl;
			flight_plan: out data port Mission;
	end VirtualMachine2;
	
	process implementation VirtualMachine2.Impl
		subcomponents
			FPLN: thread FlightPlanner.Impl;
			NFDB: thread NoFlyZoneDatabase.Impl;
		connections
			c1: port recv_map -> FPLN.recv_map;
			c2: port position_status -> FPLN.position_status;
			c3: port FPLN.flight_plan -> flight_plan;
			c4: port NFDB.zones -> FPLN.nofly_zones;
	end VirtualMachine2.Impl;

--	thread CameraManager
--		-- The CameraManager determines the gimbal settings for the onboard camera based on the current position of the UAV and the mission.
--		-- The CameraManager then sends out gimbal commands to the camera over the wifi connection
--		features
--			flight_plan: in data port Mission;
--			position_status: in event data port Coordinate.Impl;
--			gimbal_command: out event data port;
--	end CameraManager;
--
--	thread implementation CameraManager.Impl
--	end CameraManager.Impl;
--
--	process CameraManager_seL4
--		features
--			flight_plan: in data port Mission;
--			position_status: in event data port Coordinate.Impl;
--			gimbal_command: out event data port;
--	end CameraManager_seL4;
--
--	process implementation CameraManager_seL4.Impl
--		subcomponents
--			CameraManager: thread CameraManager.Impl;
--		connections
--			c1: port CameraManager.gimbal_command -> gimbal_command;
--			c2: port flight_plan -> CameraManager.flight_plan;
--			c3: port position_status -> CameraManager.position_status;
--	end CameraManager_seL4.Impl;
	

	thread UARTDriver
		-- The UARTDriver is the software that enables other SW components to communicate to other systems over the serial connection
		features
			status: out event data port Coordinate.Impl;
			mission_window: in event data port MissionWindow;
			recv_data: in event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			send_data: out event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
		annex agree {**
			assume Req001_UARTDriver "Well-formed mission window" : good_mission_window(mission_window);
			guarantee Req002_UARTDriver "A CRC shall be appended to the message to determine message correctness" : send_data.crc;
		**};
	end UARTDriver;

	thread implementation UARTDriver.Impl
	end UARTDriver.Impl;
	
	process UARTDriver_seL4
		-- The UARTDriver is the software that enables other SW components to communicate to other systems over the serial connection
		features
			mission_window: in event data port MissionWindow;
			recv_data: in event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			send_data: out event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			status: out event data port Coordinate.Impl;
		annex agree {**
			lift contract;
		**};
	end UARTDriver_seL4;

	process implementation UARTDriver_seL4.Impl
		subcomponents
			UARTDriver: thread UARTDriver.Impl;
		connections
			c1: port mission_window -> UARTDriver.mission_window;
			c2: port recv_data -> UARTDriver.recv_data;
			c3: port UARTDriver.send_data -> send_data;
			c4: port UARTDriver.status -> status;
	end UARTDriver_seL4.Impl;


	process SW
		-- The Mission Computer Software process runs all threads
		features
			radio_recv: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			radio_send: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			uart_recv: in event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			uart_send: out event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
--			wifi_recv: in event data port CASE_Model_Transformations::CASE_WIFI_Msg.Impl;
--			wifi_send: out event data port CASE_Model_Transformations::CASE_WIFI_Msg.Impl;
		annex agree {**
			guarantee Req001_SW "The Mission Computer shall output a valid mission window to the Flight Controller" : uart_send.crc;
		**};
	end SW;

	process implementation SW.Impl
		subcomponents
			RADIO: thread RadioDriver.Impl;
--			CM: thread CameraManager.Impl;
			UART: thread UARTDriver.Impl;
--			WIFI: thread WifiDriver.Impl;
			UXAS: thread group UxAS.Impl;
		connections
			c1: port radio_recv -> RADIO.recv_data;
			c2: port RADIO.send_data -> radio_send;
			c3: port RADIO.mission_command -> UXAS.recv_map;
			c4: port UXAS.mission_window -> UART.mission_window;
			c5: port UART.status -> UXAS.position_status;
			c6: port UART.status -> RADIO.status;
			c7: port UART.send_data -> uart_send;
			c8: port uart_recv -> UART.recv_data;
--			c9: port UXAS.flight_plan -> CM.flight_plan;
--			c10: port UART.status -> CM.position_status;
--			c11: port CM.gimbal_command -> WIFI.gimbal_command;
--			c12: port WIFI.send_data -> wifi_send;
--			c13: port wifi_recv -> WIFI.recv_data;
	end SW.Impl;
	
	system SW_seL4
		-- The Mission Computer Software process runs all threads
		features
			radio_recv: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			radio_send: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			uart_recv: in event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			uart_send: out event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
--			wifi_recv: in event data port CASE_Model_Transformations::CASE_WIFI_Msg.Impl;
--			wifi_send: out event data port CASE_Model_Transformations::CASE_WIFI_Msg.Impl;
		annex agree {**
			guarantee Req001_SW "The Mission Computer shall output a valid mission window to the Flight Controller" : uart_send.crc;
		**};
	end SW_seL4;

	system implementation SW_seL4.Impl
		subcomponents
			RADIO: process RadioDriver_seL4.Impl;
--			CM: thread CameraManager.Impl;
			UART: process UARTDriver_seL4.Impl;
--			WIFI: thread WifiDriver.Impl;
			UXAS: system UxAS_seL4.Impl;
		connections
			c1: port radio_recv -> RADIO.recv_data;
			c2: port RADIO.send_data -> radio_send;
			c3: port RADIO.mission_command -> UXAS.recv_map;
			c4: port UXAS.mission_window -> UART.mission_window;
			c5: port UART.status -> UXAS.position_status;
			c6: port UART.status -> RADIO.status;
			c7: port UART.send_data -> uart_send;
			c8: port uart_recv -> UART.recv_data;
--			c9: port UXAS.flight_plan -> CM.flight_plan;
--			c10: port UART.status -> CM.position_status;
--			c11: port CM.gimbal_command -> WIFI.gimbal_command;
--			c12: port WIFI.send_data -> wifi_send;
--			c13: port wifi_recv -> WIFI.recv_data;
	end SW_seL4.Impl;
	
	
	system SW_VM1
		-- The Mission Computer Software process runs all threads
		features
			radio_recv: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			radio_send: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			uart_recv: in event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			uart_send: out event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
		annex agree {**
			guarantee Req001_SW "The Mission Computer shall output a valid mission window to the Flight Controller" : uart_send.crc;
		**};
	end SW_VM1;

	system implementation SW_VM1.Impl
		subcomponents
			RADIO: process RadioDriver_seL4.Impl;
			UART: process UARTDriver_seL4.Impl;
			VM: process VirtualMachine1.Impl;
			WPM: process WaypointManager_seL4.Impl;
		connections
			c1: port radio_recv -> RADIO.recv_data;
			c2: port RADIO.send_data -> radio_send;
			c3: port RADIO.mission_command -> VM.recv_map;
			c4: port WPM.mission_window -> UART.mission_window;
			c5: port UART.status -> VM.position_status;
			c9: port UART.status -> WPM.position_status;
			c6: port UART.status -> RADIO.status;
			c7: port UART.send_data -> uart_send;
			c8: port uart_recv -> UART.recv_data;
			c10: port VM.flight_plan -> WPM.flight_plan;
	end SW_VM1.Impl;
	
	system UxAS_WPM
		features
			position_status: in event data port Coordinate.Impl;
			flight_plan: in data port Mission;
			mission_window: out event data port MissionWindow;
	end UxAS_WPM;
	
	system implementation UxAS_WPM.Impl
		subcomponents
			WPM: process WaypointManager_seL4.Impl;
		connections
			c1: port flight_plan -> WPM.flight_plan;
			c2: port WPM.mission_window -> mission_window;
			c3: port position_status -> WPM.position_status;
	end UxAS_WPM.Impl;
	
	system SW_VM2
		-- The Mission Computer Software process runs all threads
		features
			radio_recv: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			radio_send: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			uart_recv: in event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			uart_send: out event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
		annex agree {**
			guarantee Req001_SW "The Mission Computer shall output a valid mission window to the Flight Controller" : uart_send.crc;
		**};
	end SW_VM2;

	system implementation SW_VM2.Impl
		subcomponents
			RADIO: process RadioDriver_seL4.Impl;
			UART: process UARTDriver_seL4.Impl;
			VM: process VirtualMachine2.Impl;
			UXAS: system UxAS_WPM.Impl;
		connections
			c1: port radio_recv -> RADIO.recv_data;
			c2: port RADIO.send_data -> radio_send;
			c3: port RADIO.mission_command -> VM.recv_map;
			c4: port UXAS.mission_window -> UART.mission_window;
			c5: port UART.status -> VM.position_status;
			c9: port UART.status -> UXAS.position_status;
			c6: port UART.status -> RADIO.status;
			c7: port UART.send_data -> uart_send;
			c8: port uart_recv -> UART.recv_data;
			c10: port VM.flight_plan -> UXAS.flight_plan;
	end SW_VM2.Impl;
	
	
	annex agree {**
		-- ID of this UAV
		const CASE_UAV_ID : int = 42;
		fun VALID_MESSAGE(msg : RF_Msg.Impl) : bool = (msg.header.src > 0 and msg.header.dst = CASE_UAV_ID and msg.header.HMAC);
		fun TRUSTED_MESSAGE(msg : RF_Msg.Impl) : bool = msg.header.trusted;
		fun WELL_FORMED_MESSAGE(msg : RF_Msg.Impl) : bool = good_command(msg.payload);
		-- These functions check the well-formedness of message structures
		fun good_coordinate(coord : Coordinate.Impl) : bool = coord.latitude >= -90 and coord.latitude <= 90 and coord.longitude >= -180 and coord.longitude <= 180 and coord.altitude >= 0 and coord.altitude <= 15000;
		fun good_map(map : Map) : bool = forall wp in map, good_coordinate(wp);
		fun good_pattern(pattern : FlightPattern) : bool = (pattern = enum(FlightPattern, ZigZag)) or (pattern = enum(FlightPattern, StraightLine)) or (pattern = enum(FlightPattern, Perimeter));
		fun good_command(cmd : Command.Impl) : bool = good_map(cmd.map) and good_pattern(cmd.pattern);
		fun good_mission(mission : Mission) : bool = forall wp in mission, good_coordinate(wp);
		fun good_mission_window(win : MissionWindow) : bool = forall wp in win, good_coordinate(wp);
	**};

	end SW;