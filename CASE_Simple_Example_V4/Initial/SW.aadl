package SW
public

	with Data_Model;
	with Base_Types;
	with CASE_Properties;
	with HAMR;

	data Coordinate
	end Coordinate;

	data implementation Coordinate.Impl
		-- This is the structure to hold the lat/long/alt values of a coordinate
		subcomponents
			Latitude: data Base_Types::Integer_32;
			Longitude: data Base_Types::Integer_32;
			Altitude: data Base_Types::Integer_32;
		properties
			HAMR::Bit_Codec_Max_Size => 12 Bytes;
	end Coordinate.Impl;

	data Map
		-- The Map is a structure that contains a list of coordinates that encircle a
		-- region.  
		-- In this implementation, we fix the size of the map to 4 waypoints
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Coordinate.Impl));
			Data_Model::Dimension => (2);
			HAMR::Bit_Codec_Max_Size => 24 Bytes;
	end Map;

	data Command
	end Command;

	data implementation Command.Impl
		-- The Command structure contains data that the Ground Station passes to the UAV.
		-- It contains a message header, Map and Flight Pattern.
		subcomponents
			Map: data Map;
		properties
			HAMR::Bit_Codec_Max_Size => 24 Bytes;
	end Command.Impl;

	-- Message header
	data MsgHeader
	end MsgHeader;

	data implementation MsgHeader.Impl
		subcomponents
			src: data Base_Types::Unsigned_32;
			dst: data Base_Types::Unsigned_32;
		properties
			HAMR::Bit_Codec_Max_Size => 8 Bytes;
	end MsgHeader.Impl;

	-- RF Message structure
	data RF_Msg
	end RF_Msg;

	data implementation RF_Msg.Impl
		subcomponents
			header: data MsgHeader.Impl;
			payload: data Command.Impl;
		properties
			HAMR::Bit_Codec_Max_Size => 32 Bytes;
	end RF_Msg.Impl;
	
	-- This is the structure of an Attestation Request message
	-- that the Attestation Manager sends to the comm driver
	data AttestationRequestMsg
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Base_Types::Unsigned_8));
			Data_Model::Dimension => (16);
			HAMR::Bit_Codec_Max_Size => 16 Bytes;
	end AttestationRequestMsg;

	data implementation AttestationRequestMsg.Impl
	end AttestationRequestMsg.Impl;

	-- This is the structure of an Attestation Response message
	-- that the comm driver returns to the Attestation Manager
	-- when it gets a response from the Ground Station
	data AttestationResponseMsg
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Base_Types::Unsigned_8));
			Data_Model::Dimension => (2048);
			HAMR::Bit_Codec_Max_Size => 2048 Bytes;
	end AttestationResponseMsg;

	data implementation AttestationResponseMsg.Impl
	end AttestationResponseMsg.Impl;

	data TrustedIDs
	end TrustedIDs;
	
	data implementation TrustedIDs.impl		
		subcomponents
			value: data Base_Types::Integer_32;
		properties
			HAMR::Bit_Codec_Max_Size => 4 Bytes;
	end TrustedIDs.impl;

	data Mission
		-- The Mission is a list of waypoints that is generated by the Flight Planner based on a
		-- Map and Flight Pattern.
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Coordinate.Impl));
			Data_Model::Dimension => (3);
			HAMR::Bit_Codec_Max_Size => 36 Bytes;
	end Mission;

	thread RadioDriver
		-- The RadioDriver is the software that enables other SW components to communicate to other systems over RF
		features
			MissionCommand: out event data port RF_Msg.Impl;
		properties
			CASE_Properties::Comm_Driver => true;
		annex agree {**
			guarantee Req001_RadioDriver "Only valid command messages shall be forwarded to message destination components" : VALID_MESSAGE(MissionCommand);
		**};
	end RadioDriver;

	thread implementation RadioDriver.Impl
		properties
			Dispatch_Protocol => Sporadic;
	end RadioDriver.Impl;

	thread FlightPlanner
		-- The FlightPlanner accepts a command message containing a map and flight pattern, and generates a mission.
		features
			MissionCommand: in event data port RF_Msg.Impl;
			FlightPlan: out event data port Mission;
		annex agree {**
			assume Req001_FlightPlanner "The Flight Planner shall receive a valid message from the Ground Station" : VALID_MESSAGE(MissionCommand);
			guarantee Req002_FlightPlanner "The Flight Planner shall generate a valid mission" : good_mission(FlightPlan);
		**};
	end FlightPlanner;

	thread implementation FlightPlanner.Impl
		properties
			Dispatch_Protocol => Sporadic;
	end FlightPlanner.Impl;

	thread FlightController
		-- The FlightController is the software that flies the UAV
		features
			FlightPlan: in event data port Mission;
		annex agree {**
			assume Req001_FlightController "Well-formed mission window" : good_mission(FlightPlan);
		**};
	end FlightController;

	thread implementation FlightController.Impl
		properties
			Dispatch_Protocol => Sporadic;
	end FlightController.Impl;

	process SW
	end SW;

	process implementation SW.Impl
		subcomponents
			Radio: thread RadioDriver.Impl;
			FlightPlanner: thread FlightPlanner.Impl;
			FlightController: thread FlightController.Impl;
		connections
			c1: port Radio.MissionCommand -> FlightPlanner.MissionCommand;
			c2: port FlightPlanner.FlightPlan -> FlightController.FlightPlan;
	end SW.Impl;

	annex agree {**
		-- ID of this UAV
		const CASE_UAV_ID : int = 42;
		fun VALID_MESSAGE(msg : RF_Msg.Impl) : bool = (msg.header.src > 0 and msg.header.dst = CASE_UAV_ID);
		fun WELL_FORMED_MESSAGE(msg : RF_Msg.Impl) : bool = good_command(msg.payload);
		-- These functions check the well-formedness of message structures
		fun good_coordinate(coord : Coordinate.Impl) : bool = coord.Latitude >= -90 and coord.Latitude <= 90 and coord.Longitude >= -180 and coord.Longitude <= 180 and coord.Altitude >= 0 and coord.Altitude <= 15000;
		fun good_map(map : Map) : bool = forall wp in map, good_coordinate(wp);
		fun good_command(cmd : Command.Impl) : bool = good_map(cmd.Map);
		fun good_mission(mission : Mission) : bool = forall wp in mission, good_coordinate(wp);
	**};
	
end SW;