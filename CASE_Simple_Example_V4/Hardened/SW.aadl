package SW
public

	with Data_Model;
	with Base_Types;
	with CASE_Properties;
	with CASE_Model_Transformations;

	thread GeofenceMonitor
		features
			FlyZones: in data port MapArray;
			Alert: out event port;
			FlightPlan_In: in event data port Mission;
			FlightPlan_Out: out event data port Mission;
		properties
			CASE_Properties::Monitoring => 100;
			CASE_Properties::Component_Spec => ("GeofenceMonitor_Alert", "GeofenceMonitor_FlightPlan_Out");
		annex agree {**
			const is_latched : bool = true;
			property GeofenceMonitor_policy = false;
			property alerted = (not GeofenceMonitor_policy) -> ((is_latched and pre(alerted)) or (event(FlightPlan_In) and not GeofenceMonitor_policy));
			guarantee GeofenceMonitor_Alert "A violation of the monitor policy shall trigger an alert" : alerted <=> event(Alert);
			guarantee GeofenceMonitor_FlightPlan_Out "A violation of the monitor policy shall prevent propagation of the Observed input." : if alerted then not event(FlightPlan_Out) else event(FlightPlan_Out) and FlightPlan_Out = FlightPlan_In;
		**};
	end GeofenceMonitor;

	thread implementation GeofenceMonitor.Impl
		properties
			Dispatch_Protocol => Sporadic;
	end GeofenceMonitor.Impl;

	thread ResponseMonitor
		features
			Alert: out event port;
			FlightPlan: in event data port Mission;
			MissionCommand: in event data port RF_Msg.Impl;
		properties
			CASE_Properties::Monitoring => 100;
			CASE_Properties::Component_Spec => ("ResponseMonitor_Alert");
		annex agree {**
			const is_latched : bool = false;
			property ResponseMonitor_policy = false;
			property alerted = (not ResponseMonitor_policy) -> ((is_latched and pre(alerted)) or (event(FlightPlan) and not ResponseMonitor_policy));
			guarantee ResponseMonitor_Alert "A violation of the monitor policy shall trigger an alert" : alerted <=> event(Alert);
		**};
	end ResponseMonitor;

	thread implementation ResponseMonitor.Impl
		properties
			Dispatch_Protocol => Sporadic;
	end ResponseMonitor.Impl;

	thread CASE_AttestationGate
		features
			MissionCommand_in: in event data port RF_Msg.Impl;
			MissionCommand_out: out event data port RF_Msg.Impl;
			TrustedIds: in event data port Address.Impl;
		properties
			CASE_Properties::Gating => 100;
	end CASE_AttestationGate;

	thread implementation CASE_AttestationGate.Impl
		properties
			Dispatch_Protocol => Sporadic;
	end CASE_AttestationGate.Impl;

	thread CASE_AttestationManager
		features
			AttestationRequest: out event data port CASE_Model_Transformations::CASE_AttestationRequestMsg.Impl;
			AttestationResponse: in event data port CASE_Model_Transformations::CASE_AttestationResponseMsg.Impl;
			TrustedIds: out event data port Address.Impl;
		properties
			CASE_Properties::Attesting => 100;
	end CASE_AttestationManager;

	thread implementation CASE_AttestationManager.Impl
		properties
			CASE_Properties::Cache_Timeout => 5 min;
			CASE_Properties::Cache_Size => 4;
			Dispatch_Protocol => Sporadic;
	end CASE_AttestationManager.Impl;

	thread CASE_Filter
		features
			Input: in event data port RF_Msg.Impl;
			Output: out event data port RF_Msg.Impl;
		properties
			CASE_Properties::Filtering => 100;
			CASE_Properties::Component_Spec => ("CASE_Filter_Output");
		annex agree {**
			property CASE_Filter_policy = WELL_FORMED_MESSAGE(Input);
			guarantee CASE_Filter_Output "The filter output shall be well-formed" :
			if event(Input) and CASE_Filter_policy then
			event(Output) and Output = Input
			else
			not event(Output);
		**};
	end CASE_Filter;

	thread implementation CASE_Filter.Impl
		properties
			Dispatch_Protocol => Sporadic;
	end CASE_Filter.Impl;

	data Coordinate
	end Coordinate;

	data implementation Coordinate.Impl
		-- This is the structure to hold the lat/long/alt values of a coordinate
		subcomponents
			Latitude: data Base_Types::Integer;
			Longitude: data Base_Types::Integer;
			Altitude: data Base_Types::Integer;
	end Coordinate.Impl;

	data Map
		-- The Map is a structure that contains a list of coordinates that encircle a
		-- region.  
		-- In this implementation, we fix the size of the map to 4 waypoints
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Coordinate.Impl));
			Data_Model::Dimension => (4);
	end Map;

	data MapArray
		-- The MapArray is a structure that hold multiple Maps
		-- In this implementation, we fix the size of the map array to 5 maps
		-- Future versions will use an array
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Map));
			Data_Model::Dimension => (5);
	end MapArray;

	data FlightPattern
		-- The Flight Pattern is an enumeration that defines how the UAV will fly through the
		-- sensing region to conduct surveillance.
		properties
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("ZigZag", "StraightLine", "Perimeter");
	end FlightPattern;

	data implementation FlightPattern.Impl
	end FlightPattern.Impl;

	data Command
	end Command;

	data implementation Command.Impl
		-- The Command structure contains data that the Ground Station passes to the UAV.
		-- It contains a message header, Map and Flight Pattern.
		subcomponents
			Map: data Map;
			Pattern: data FlightPattern;
	end Command.Impl;

	-- Message header
	data MsgHeader
	end MsgHeader;

	data implementation MsgHeader.Impl
		subcomponents
			src: data Base_Types::Unsigned_32;
			dst: data Base_Types::Unsigned_32;
			trusted: data Base_Types::Boolean;
			HMAC: data Base_Types::Boolean;
	end MsgHeader.Impl;

	-- RF Message structure
	data RF_Msg
	end RF_Msg;

	data implementation RF_Msg.Impl
		subcomponents
			header: data MsgHeader.Impl;
			payload: data Command.Impl;
	end RF_Msg.Impl;

	data Address
	end Address;

	data implementation Address.Impl
		subcomponents
			value: data Base_Types::Unsigned_32[4];
	end Address.Impl;

	data Mission
		-- The Mission is a list of waypoints that is generated by the Flight Planner based on a
		-- Map and Flight Pattern.
		-- For this implementation, we fix the size of the Mission to 10 waypoints.
		-- Future versions will use an array
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Coordinate.Impl));
			Data_Model::Dimension => (10);
	end Mission;

	data MissionWindow
		-- The Mission Window is a list of waypoints that the Waypoint Manager assembles from the Mission.
		-- For this implementation, we fix the size of the Mission Window to 4 waypoints.
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Coordinate.Impl));
			Data_Model::Dimension => (4);
	end MissionWindow;

	thread RadioDriver
		-- The RadioDriver is the software that enables other SW components to communicate to other systems over RF
		features
			Alert: in event port;
			RecvData: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			SendData: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			MissionCommand: out event data port RF_Msg.Impl;
		properties
			CASE_Properties::Comm_Driver => true;
		annex agree {**
			guarantee Req001_RadioDriver "Only valid command messages shall be forwarded to message destination components" : VALID_MESSAGE(MissionCommand);
		**};
	end RadioDriver;

	thread implementation RadioDriver.Impl
	end RadioDriver.Impl;

	thread FlightPlanner
		-- The FlightPlanner is an abstraction for UxAS.
		-- It accepts a command message containing a map and flight pattern, and generates a mission.
		features
			FlightPlan: out event data port Mission;
			MissionCommand: in event data port RF_Msg.Impl;
		annex agree {**
			assume Req_Wellformed_MissionCommand "FlightPlanner component shall only receive well-formed messages" : event(MissionCommand) => WELL_FORMED_MESSAGE(MissionCommand);
			assume Req001_FlightPlanner "The Flight Planner shall receive a valid message from the Ground Station" : event(MissionCommand) => VALID_MESSAGE(MissionCommand);
			guarantee Req002_FlightPlanner "The Flight Planner shall generate a valid mission" : good_mission(FlightPlan);
		**};
	end FlightPlanner;

	thread implementation FlightPlanner.Impl
	end FlightPlanner.Impl;

	thread FlyZoneDatabase
		-- The NoFlyZoneDatabase is a collection of polygons that represent areas on a map which the UAV should avoid.
		-- The database is populated at build-time and stored in memory.
		-- When provided a map of a region, it will return all no-fly areas within that region.
		features
			FlyZones: out data port MapArray;
	end FlyZoneDatabase;

	thread implementation FlyZoneDatabase.Impl
	end FlyZoneDatabase.Impl;

	thread WaypointManager
		-- The WaypointManager divides a mission into a small window of waypoints suitable for the FlightController.
		-- Because the FlightController can only process a small number of waypoints at a time, the WaypointManager
		-- creates these mission windows in response to the current position of the UAV, provided by the FlightController GPS.
		features
			ReturnHome: in event port;
			FlightPlan: in event data port Mission;
			MissionWindow: out event data port MissionWindow;
			Status: in event data port Coordinate.Impl;
		annex agree {**
			assume Req001_WaypointManager "The Waypoint Manager shall receive a well-formed mission" : good_mission(FlightPlan);
			guarantee Req002_WaypointManager "The Waypoint Manager shall output a well-formed mission window" : good_mission_window(MissionWindow);
		**};
	end WaypointManager;

	thread implementation WaypointManager.Impl
	end WaypointManager.Impl;

	thread UARTDriver
		-- The UARTDriver is the software that enables other SW components to communicate to other systems over the serial connection
		features
			Status: out event data port Coordinate.Impl;
			MissionWindow: in event data port MissionWindow;
			RecvData: in event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			SendData: out event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
		annex agree {**
			assume Req001_UARTDriver "Well-formed mission window" : good_mission_window(MissionWindow);
			guarantee Req002_UARTDriver "A CRC shall be appended to the message to determine message correctness" : SendData.crc;
		**};
	end UARTDriver;

	thread implementation UARTDriver.Impl
	end UARTDriver.Impl;

	thread RadioDriver_Attestation
		features
			Alert: in event port;
			RecvData: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			SendData: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			MissionCommand: out event data port RF_Msg.Impl;
			AttestationRequest: in event data port CASE_Model_Transformations::CASE_AttestationRequestMsg.Impl;
			AttestationResponse: out event data port CASE_Model_Transformations::CASE_AttestationResponseMsg.Impl;
		properties
			CASE_Properties::Comm_Driver => true;
		annex agree {**
			guarantee Req001_RadioDriver_Attestation "Only valid command messages shall be forwarded to message destination components" : VALID_MESSAGE(MissionCommand);
		**};
	end RadioDriver_Attestation;

	thread implementation RadioDriver_Attestation.Impl
	end RadioDriver_Attestation.Impl;

	process SW
		-- The Mission Computer Software process runs all threads
		features
			RadioRecv: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			RadioSend: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			UartRecv: in event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			UartSend: out event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
		annex agree {**
			guarantee Req001_SW "The Mission Computer shall output a valid mission window to the Flight Controller" : UartSend.crc;
		**};
	end SW;

	process implementation SW.Impl
		subcomponents
			Radio: thread RadioDriver_Attestation.Impl;
			FlightPlanner: thread FlightPlanner.Impl;
			WaypointManager: thread WaypointManager.Impl;
			UART: thread UARTDriver.Impl;
			FlyZones: thread FlyZoneDatabase.Impl;
			Filter: thread CASE_Filter.Impl;
			AttestationManager: thread CASE_AttestationManager.Impl;
			AttestationGate: thread CASE_AttestationGate.Impl;
			ResponseMonitor: thread ResponseMonitor.Impl;
			GeofenceMonitor: thread GeofenceMonitor.Impl;
		connections
			c1: port RadioRecv -> Radio.RecvData;
			c2: port Radio.SendData -> RadioSend;
			c3: port AttestationGate.MissionCommand_out -> Filter.Input;
			c4: port GeofenceMonitor.FlightPlan_Out -> WaypointManager.FlightPlan;
			c5: port WaypointManager.MissionWindow -> UART.MissionWindow;
			c6: port UART.status -> WaypointManager.Status;
			c7: port UART.SendData -> UartSend;
			c8: port UartRecv -> UART.RecvData;
			c9: port Filter.Output -> FlightPlanner.MissionCommand;
			c10: port FlightPlanner.FlightPlan -> ResponseMonitor.FlightPlan;
			c11: port AttestationGate.MissionCommand_out -> ResponseMonitor.MissionCommand;
			c12: port ResponseMonitor.Alert -> Radio.Alert;
			c13: port FlightPlanner.FlightPlan -> GeofenceMonitor.FlightPlan_In;
			c14: port FlyZones.FlyZones -> GeofenceMonitor.FlyZones;
			c15: port GeofenceMonitor.Alert -> WaypointManager.ReturnHome;
			c16: port Radio.MissionCommand -> AttestationGate.MissionCommand_In;
			c17: port AttestationManager.AttestationRequest -> Radio.AttestationRequest;
			c18: port Radio.AttestationResponse -> AttestationManager.AttestationResponse;
			c19: port AttestationManager.TrustedIds -> AttestationGate.TrustedIds;
	end SW.Impl;

	annex agree {**
		-- ID of this UAV
		const CASE_UAV_ID : int = 42;
		fun VALID_MESSAGE(msg : RF_Msg.Impl) : bool = (msg.header.src > 0 and msg.header.dst = CASE_UAV_ID and msg.header.HMAC);
		fun TRUSTED_MESSAGE(msg : RF_Msg.Impl) : bool = msg.header.trusted;
		fun WELL_FORMED_MESSAGE(msg : RF_Msg.Impl) : bool = good_command(msg.payload);
		-- These functions check the well-formedness of message structures
		fun good_coordinate(coord : Coordinate.Impl) : bool = coord.Latitude >= -90 and coord.Latitude <= 90 and coord.Longitude >= -180 and coord.Longitude <= 180 and coord.Altitude >= 0 and coord.Altitude <= 15000;
		fun good_map(map : Map) : bool = forall wp in map, good_coordinate(wp);
		fun good_pattern(pattern : FlightPattern) : bool = (pattern = enum(FlightPattern, ZigZag)) or (pattern = enum(FlightPattern, StraightLine)) or (pattern = enum(FlightPattern, Perimeter));
		fun good_command(cmd : Command.Impl) : bool = good_map(cmd.Map) and good_pattern(cmd.Pattern);
		fun good_mission(mission : Mission) : bool = forall wp in mission, good_coordinate(wp);
		fun good_mission_window(win : MissionWindow) : bool = forall wp in win, good_coordinate(wp);
	**};

	process RadioDriver_Attestation_seL4
		features
			Alert: in event port;
			RecvData: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			SendData: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			MissionCommand: out event data port RF_Msg.Impl;
			AttestationRequest: in event data port CASE_Model_Transformations::CASE_AttestationRequestMsg.Impl;
			AttestationResponse: out event data port CASE_Model_Transformations::CASE_AttestationResponseMsg.Impl;
		properties
			CASE_Properties::Comm_Driver => true;
	end RadioDriver_Attestation_seL4;

	process implementation RadioDriver_Attestation_seL4.Impl
		subcomponents
			RadioDriver_Attestation: thread RadioDriver_Attestation.Impl;
		connections
			c1: port AttestationRequest -> RadioDriver_Attestation.AttestationRequest;
			c2: port RadioDriver_Attestation.AttestationResponse -> AttestationResponse;
			c3: port Alert -> RadioDriver_Attestation.Alert;
			c4: port RecvData -> RadioDriver_Attestation.RecvData;
			c5: port RadioDriver_Attestation.SendData -> SendData;
			c6: port RadioDriver_Attestation.MissionCommand -> MissionCommand;
		annex agree {**
			lift contract;
		**};
	end RadioDriver_Attestation_seL4.Impl;

	process FlightPlanner_seL4
		features
			FlightPlan: out event data port Mission;
			MissionCommand: in event data port RF_Msg.Impl;
	end FlightPlanner_seL4;

	process implementation FlightPlanner_seL4.Impl
		subcomponents
			FlightPlanner: thread FlightPlanner.Impl;
		connections
			c1: port FlightPlanner.FlightPlan -> FlightPlan;
			c2: port MissionCommand -> FlightPlanner.MissionCommand;
		annex agree {**
			lift contract;
		**};
	end FlightPlanner_seL4.Impl;

	process WaypointManager_seL4
		features
			ReturnHome: in event port;
			FlightPlan: in event data port Mission;
			MissionWindow: out event data port MissionWindow;
			Status: in event data port Coordinate.Impl;
	end WaypointManager_seL4;

	process implementation WaypointManager_seL4.Impl
		subcomponents
			WaypointManager: thread WaypointManager.Impl;
		connections
			c1: port ReturnHome -> WaypointManager.ReturnHome;
			c2: port Status -> WaypointManager.Status;
			c3: port WaypointManager.MissionWindow -> MissionWindow;
			c4: port FlightPlan -> WaypointManager.FlightPlan;
		annex agree {**
			lift contract;
		**};
	end WaypointManager_seL4.Impl;

	process UARTDriver_seL4
		features
			Status: out event data port Coordinate.Impl;
			MissionWindow: in event data port MissionWindow;
			RecvData: in event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			SendData: out event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
	end UARTDriver_seL4;

	process implementation UARTDriver_seL4.Impl
		subcomponents
			UARTDriver: thread UARTDriver.Impl;
		connections
			c1: port UARTDriver.Status -> Status;
			c2: port RecvData -> UARTDriver.RecvData;
			c3: port MissionWindow -> UARTDriver.MissionWindow;
			c4: port UARTDriver.SendData -> SendData;
		annex agree {**
			lift contract;
		**};
	end UARTDriver_seL4.Impl;

	process FlyZoneDatabase_seL4
		features
			FlyZones: out data port MapArray;
	end FlyZoneDatabase_seL4;

	process implementation FlyZoneDatabase_seL4.Impl
		subcomponents
			FlyZoneDatabase: thread FlyZoneDatabase.Impl;
		connections
			c1: port FlyZoneDatabase.FlyZones -> FlyZones;
	end FlyZoneDatabase_seL4.Impl;

	process CASE_Filter_seL4
		features
			Input: in event data port RF_Msg.Impl;
			Output: out event data port RF_Msg.Impl;
		properties
			CASE_Properties::Filtering => 100;
			CASE_Properties::Component_Spec => ("CASE_Filter_Output");
	end CASE_Filter_seL4;

	process implementation CASE_Filter_seL4.Impl
		subcomponents
			CASE_Filter: thread CASE_Filter.Impl;
		connections
			c1: port Input -> CASE_Filter.Input;
			c2: port CASE_Filter.Output -> Output;
		annex agree {**
			lift contract;
		**};
	end CASE_Filter_seL4.Impl;

	process CASE_AttestationManager_seL4
		features
			AttestationRequest: out event data port CASE_Model_Transformations::CASE_AttestationRequestMsg.Impl;
			AttestationResponse: in event data port CASE_Model_Transformations::CASE_AttestationResponseMsg.Impl;
			TrustedIds: out event data port Address.Impl;
		properties
			CASE_Properties::Attesting => 100;
	end CASE_AttestationManager_seL4;

	process implementation CASE_AttestationManager_seL4.Impl
		subcomponents
			CASE_AttestationManager: thread CASE_AttestationManager.Impl;
		connections
			c1: port CASE_AttestationManager.AttestationRequest -> AttestationRequest;
			c2: port CASE_AttestationManager.TrustedIds -> TrustedIds;
			c3: port AttestationResponse -> CASE_AttestationManager.AttestationResponse;
		properties
			CASE_Properties::Cache_Timeout => 5 min;
			CASE_Properties::Cache_Size => 4;
	end CASE_AttestationManager_seL4.Impl;

	process CASE_AttestationGate_seL4
		features
			MissionCommand_in: in event data port RF_Msg.Impl;
			MissionCommand_out: out event data port RF_Msg.Impl;
			TrustedIds: in event data port Address.Impl;
		properties
			CASE_Properties::Gating => 100;
	end CASE_AttestationGate_seL4;

	process implementation CASE_AttestationGate_seL4.Impl
		subcomponents
			CASE_AttestationGate: thread CASE_AttestationGate.Impl;
		connections
			c1: port CASE_AttestationGate.MissionCommand_out -> MissionCommand_out;
			c2: port MissionCommand_in -> CASE_AttestationGate.MissionCommand_in;
			c3: port TrustedIds -> CASE_AttestationGate.TrustedIds;
	end CASE_AttestationGate_seL4.Impl;

	process ResponseMonitor_seL4
		features
			Alert: out event port;
			FlightPlan: in event data port Mission;
			MissionCommand: in event data port RF_Msg.Impl;
		properties
			CASE_Properties::Monitoring => 100;
			CASE_Properties::Component_Spec => ("ResponseMonitor_Alert");
	end ResponseMonitor_seL4;

	process implementation ResponseMonitor_seL4.Impl
		subcomponents
			ResponseMonitor: thread ResponseMonitor.Impl;
		connections
			c1: port MissionCommand -> ResponseMonitor.MissionCommand;
			c2: port FlightPlan -> ResponseMonitor.FlightPlan;
			c3: port ResponseMonitor.Alert -> Alert;
		annex agree {**
			lift contract;
		**};
	end ResponseMonitor_seL4.Impl;

	process GeofenceMonitor_seL4
		features
			FlyZones: in data port MapArray;
			Alert: out event port;
			FlightPlan_In: in event data port Mission;
			FlightPlan_Out: out event data port Mission;
		properties
			CASE_Properties::Monitoring => 100;
			CASE_Properties::Component_Spec => ("GeofenceMonitor_Alert", "GeofenceMonitor_FlightPlan_Out");
	end GeofenceMonitor_seL4;

	process implementation GeofenceMonitor_seL4.Impl
		subcomponents
			GeofenceMonitor: thread GeofenceMonitor.Impl;
		connections
			c1: port FlightPlan_In -> GeofenceMonitor.FlightPlan_In;
			c2: port GeofenceMonitor.Alert -> Alert;
			c3: port FlyZones -> GeofenceMonitor.FlyZones;
			c4: port GeofenceMonitor.FlightPlan_Out -> FlightPlan_Out;
		annex agree {**
			lift contract;
		**};
	end GeofenceMonitor_seL4.Impl;

	system SW_seL4
		features
			RadioRecv: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			RadioSend: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			UartRecv: in event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			UartSend: out event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
		annex agree {**
			guarantee Req001_SW_seL4 "The Mission Computer shall output a valid mission window to the Flight Controller" : UartSend.crc;
		**};
	end SW_seL4;

	system implementation SW_seL4.Impl
		subcomponents
			FlyZones: process FlyZoneDatabase_seL4.Impl;
			Radio: process RadioDriver_Attestation_seL4.Impl;
			UART: process UARTDriver_seL4.Impl;
			AttestationGate: process CASE_AttestationGate_seL4.Impl;
			Filter: process CASE_Filter_seL4.Impl;
			WaypointManager: process WaypointManager_seL4.Impl;
			AttestationManager: process CASE_AttestationManager_seL4.Impl;
			GeofenceMonitor: process GeofenceMonitor_seL4.Impl;
			ResponseMonitor: process ResponseMonitor_seL4.Impl;
			FlightPlanner: process FlightPlanner_seL4.Impl;
		connections
			c1: port RadioRecv -> Radio.RecvData;
			c2: port Radio.SendData -> RadioSend;
			c3: port AttestationGate.MissionCommand_out -> Filter.Input;
			c4: port GeofenceMonitor.FlightPlan_Out -> WaypointManager.FlightPlan;
			c5: port WaypointManager.MissionWindow -> UART.MissionWindow;
			c6: port UART.Status -> WaypointManager.Status;
			c7: port UART.SendData -> UartSend;
			c8: port UartRecv -> UART.RecvData;
			c9: port Filter.Output -> FlightPlanner.MissionCommand;
			c10: port FlightPlanner.FlightPlan -> ResponseMonitor.FlightPlan;
			c11: port AttestationGate.MissionCommand_out -> ResponseMonitor.MissionCommand;
			c12: port ResponseMonitor.Alert -> Radio.Alert;
			c13: port FlightPlanner.FlightPlan -> GeofenceMonitor.FlightPlan_In;
			c14: port FlyZones.FlyZones -> GeofenceMonitor.FlyZones;
			c15: port GeofenceMonitor.Alert -> WaypointManager.ReturnHome;
			c16: port Radio.MissionCommand -> AttestationGate.MissionCommand_In;
			c17: port AttestationManager.AttestationRequest -> Radio.AttestationRequest;
			c18: port Radio.AttestationResponse -> AttestationManager.AttestationResponse;
			c19: port AttestationManager.TrustedIds -> AttestationGate.TrustedIds;
	end SW_seL4.Impl;
end SW;